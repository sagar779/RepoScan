# CSP Implementation & Analysis Guide

This document provides a strategic guide on how to analyze the output generated by the **Inline Code Scanner** and use it to implement a robust **Content Security Policy (CSP)** for your .NET web applications.

## 1. Analyzing the Excel Report

The scanner generates an Excel report with three main data tabs. Here is how to use each one:

### A. Inline JavaScript Tab
This is the most critical tab for security. It lists findings with their **File Path**, **Start Line**, **End Line**, and **Full Code**.

*   **Filter by `Type`**:
    *   **Event Handler (`onclick`, `onload`, etc.)**: These are legacy patterns.
        *   *Action*: Refactor these into external `.js` files using `addEventListener`. You can copy the code from the **Full Code** column.
    *   **Script Block**: `<script>...</script>` tags inside HTML.
        *   *Action*: If they contain logic, move to an external file. Use **Start Line** and **End Line** to locate them.
    *   **URI (`javascript:void(0)`)**: Often found in `<a>` tags.
        *   *Action*: Replace with `href="#"` and a click event listener.

*   **Review `AJAX Detected` Column**:
    *   If "Yes", this script makes network requests.
    *   *Action*: You must identify the *destination* of these requests to configure the `connect-src` directive in your CSP.

### B. External Resources Tab
This tab lists all third-party libraries (jQuery, Analytics, Fonts) your app loads.

*   **Action**: Use this list to build your **whitelist** for `script-src` and `style-src`. The **File Path** and **Start Line** tell you exactly where they are included.
*   *Example*: If you see `https://cdn.jsdelivr.net/...`, you need to add `https://cdn.jsdelivr.net` to your CSP allowed sources.

### C. Inline CSS Tab
Inline styles (`style="color: red;"`) are less risky than scripts but still blocked by strict CSPs.

*   **Action**: Move these styles to external `.css` classes.
*   *Alternative*: If refactoring is impossible, you may need to allow `unsafe-inline` for `style-src` (less dangerous than doing so for scripts), or use hashes.

---

## 2. CSP Implementation Strategy

The goal is to move from a "scanning" state to a "blocking" state.

### Step 1: Remediation (The Cleanup)
Use the report to **eliminate** inline code.
1.  **Refactor**: Move `onclick` logic to external JS files.
2.  **Externalize**: Move `<style>` blocks to CSS files.

### Step 2: Policy Generation
Construct your policy based on the "External Resources" tab.

**Example Policy:**
```http
Content-Security-Policy: 
  default-src 'self'; 
  script-src 'self' https://trusted.cdn.com 'nonce-random123'; 
  style-src 'self' 'unsafe-inline'; 
  connect-src 'self' https://api.yoursite.com;
```

*   **`script-src`**: Avoid `unsafe-inline` at all costs. Use Nonces for necessary inline blocks.
*   **`style-src`**: `unsafe-inline` is often tolerated for styles due to the difficulty of removing all `style="..."` attributes in legacy apps.

### Step 3: Deployment (Report-Only Mode)
Before blocking anything, run in "Report-Only" mode. This logs violations without breaking the app.
```http
Content-Security-Policy-Report-Only: ...
```

---

## 3. Special Context: AJAX & CSP

**AJAX (Asynchronous JavaScript and XML)** refers to the technique of making HTTP requests from the browser after the page has loaded (using `fetch`, `XMLHttpRequest`, `axios`).

### Why it matters for CSP:
Standard CSP controls *where* scripts can load from (`script-src`), but **`connect-src`** controls *where* the browser can send data to (API calls, data fetches).

### Using the Scanner for AJAX:
1.  Filter the **Inline JavaScript** tab for **`AJAX Detected = Yes`**.
2.  Look at the **`Code Snippet`** or **`Full Code`**.
3.  Identify the URL endpoints being called (e.g., `/api/user`, `https://external-api.com`).
4.  Ensure these domains are added to your `connect-src` directive.
    *   *Risk*: If you miss this, your API calls will fail, breaking dynamic functionality.

---

## 4. Special Context: .NET & CSP

.NET applications, particularly **ASP.NET Web Forms**, present unique challenges for CSP.

### The Problem: Auto-Generated JavaScript
ASP.NET Web Forms controls often inject inline JavaScript automatically.
*   **`__doPostBack`**: The most common culprit. It generates `href="javascript:__doPostBack(...)"` links for PostBack events.
*   **Validator Controls**: RequiredFieldValidators inject inline scripts for client-side validation.

### Solutions for .NET:

#### 1. The Nonce Approach (Recommended for .NET 4.x / Core)
You cannot easily remove `__doPostBack`. Instead, you must "allow" it cryptographically.
*   Generate a cryptographic **Nonce** (random token) on the server for each request.
*   Apply this nonce to the auto-generated script tags.
*   *Note*: In strict Web Forms, this is hard because you don't control the rendering of `__doPostBack`.

#### 2. The "Strict-Dynamic" Approach (Modern)
If you can migrate to modern libraries, use `strict-dynamic` which allows scripts loaded by a trusted script to also run.

#### 3. Handling Web Forms Legacy (The "Refactor" Wall)
If you have thousands of `asp:Button` controls generating inline `onclick`:
*   **Short Term**: You might be forced to use `script-src 'unsafe-inline'` locally while you refactor.
*   **Long Term**: Replace `asp:Button` (server control) with standard HTML `<button>` elements and bind events via jQuery/Vanilla JS in external files.

### Configuring CSP in .NET (`web.config`)
You can add the header globally in your `web.config`:

```xml
<configuration>
  <system.webServer>
    <httpProtocol>
      <customHeaders>
        <add name="Content-Security-Policy" 
             value="default-src 'self'; script-src 'self' https://trusted.com;" />
      </customHeaders>
    </httpProtocol>
  </system.webServer>
</configuration>
```
*Tip*: Use `Content-Security-Policy-Report-Only` first to test your rules against the scanner's findings.

---

## 5. Refactoring Workflow: Using Code Bundles
You asked: *"Can I use the separate files to substitute for inline and internal css/js?"*
**Yes!** That is the exact purpose of the **Extracted File** column and the `output/codebundle` folder.

### **Does it track "Internal" vs "Inline"?**
Yes. The tool tracks both:
1.  **"Inline" (Attributes)**: Detected as **Type = Event Handler** (e.g., `onclick="..."`) or **Style Attribute**.
2.  **"Internal" (Blocks)**: Detected as **Type = Script Block** (e.g., `<script>...</script>`) or **Style Block**.
    *   *Note*: Both appear in the "Inline JavaScript/CSS" tabs because they break strict CSPs (unless you use Nonces).

### **How to Substitute (Step-by-Step)**

**Scenario**: You have a large script block in `contact.aspx`.

1.  **Locate** the finding in the Excel Tracker.
    *   *File Path*: `Views/contact.aspx`
    *   *Type*: `Script Block`
    *   *Extracted File*: `Views_contact.aspx_50-80_Script_Block.js`
2.  **Retrieve** the file from `output/codebundle/js/Views_contact.aspx_50-80_Script_Block.js`.
3.  **Rename & Move** it to your project's assets folder (e.g., `js/pages/contact.js`).
4.  **Replace** the code in `contact.aspx`:
    
    **Before:**
    ```html
    <script>
       function validateForm() { ... }
    </script>
    ```

    **After:**
    ```html
    <script src="/js/pages/contact.js"></script>
    ```
5.  **Whitelist** the file in your CSP (if strictly checking origins, though `self` covers local files).

**For Attributes (`onclick`):**
You cannot just replace `onclick="..."` with `<script src="...">`. You must **rewrite** the logic.
1.  Take the extracted code from the bundle.
2.  Put it in a JS file.
3.  Use `document.getElementById('btn').addEventListener('click', ...)` instead of `onclick`.
